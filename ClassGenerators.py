from ClassDescriptors import ClassDescription, Attribute, ParentClass


def create_include_guards(classDesc: ClassDescription) -> list[str]:
    """Generates include guards for the class based on whether it is a template class or not. (`#ifndef`, `#define`, `#endif`)"""
    if classDesc.template:
        return [f"#ifndef {classDesc.name.upper()}_HPP", f"#define {classDesc.name.upper()}_HPP", "#endif"]
    else:
        return []


def create_inclusions(classDesc: ClassDescription) -> list[str]:
    """Generates namespace inclusions, and include statements if the types: string, vector, unique_ptr, shared_ptr, or weak_ptr are used for attributes, without std::
    . Includes in format `#include <file>` and namespaces in format `using std::type;`.'"""
    namespaces_used = []
    includes = []
    type_include_association = {
        "string": "#include <string>",
        "vector": "#include <vector>",
        "unique_ptr": "#include <memory>",
        "shared_ptr": "#include <memory>",
        "weak_ptr": "#include <memory>"
    }
    for attribute in classDesc.attributes:
        attribute: Attribute
        # Check if attribute needs to be included
        if attribute.type in ["string", "vector", "unique_ptr", "shared_ptr", "weak_ptr"]:
            # Use std:: namespace for these types
            if f"using std::{attribute.type}" not in namespaces_used:
                namespaces_used.append(f"using std::{attribute.type};")
            # Include these types if not already included
            if type_include_association[attribute.type] not in includes:
                includes.append(type_include_association[attribute.type])
    return includes, namespaces_used


def create_class_declaration(classDesc: ClassDescription) -> tuple[str, str]:
    """Generates Declaration for the class, including template specialisation if it exists. Template line in format
    `template <>` or `template <typename T>` ("" if class is not template) and declaration line in format `class ClassName : public ParentClass, protected ParentClass {`."""
    template_line = ""
    declaration_line = ""
    # Generate template line
    if classDesc.template:
        if classDesc.specialisation:
            template_line = f"template <>"
        else:
            template_line = f"template <typename T>"
    # Generate declaration line
    declaration_line += f"class {classDesc.name}"
    # Add template specialisation if it exists
    if classDesc.specialisation:
        declaration_line += f"<{classDesc.specialisation}>"
    # Add inheritance if exists - in order
    if classDesc.parents:
        # Add colon to indicate inheritance
        declaration_line += " : "
        # Iterate through parents to create inheritance declaration
        for i, parent in enumerate(classDesc.parents):
            parent: ParentClass
            # Ensure parent classes are in order
            if parent.position != i:
                raise IndexError(
                    f"Parent class {parent.name} is not in the correct position in the inheritance list.")
            # Add virtural keyword, inheritance type, and name or parent
            if i > 0:
                declaration_line += ", "
            if parent.virtual:
                declaration_line += "virtual "
            declaration_line += f"{parent.inheritance.value} {parent.name}"
    # Add opening brace to declaration line
    declaration_line += " {"
    return template_line, declaration_line


def get_attribute_name(attribute: Attribute) -> str:
    """Returns the name of an attribute based on its dataclass: `get_set_attrX` where X is the index of the attribute, and get and set
    are included if the attribute has a getter or setter respectively."""
    name = ""
    if attribute.getter:
        name += "_g"
    if attribute.setter:
        name += "_s"
    name = "attr" + str(attribute.index) + name
    return name


def create_attributes(classDesc: ClassDescription) -> list[str]:
    """Generates attribute declarations for the class, in the format `\\t{type} {attr_name};` where `type` is the type of the attribute
    and `attr_name` is the name of the attribute generated by `get_attribute_name`."""
    attributes: list[str] = []
    for attribute in classDesc.attributes:
        attribute: Attribute
        # Create attribute
        attributes.append(
            f"\t{attribute.type} {get_attribute_name(attribute)};")
    return attributes


def get_method_definitions(classDesc: ClassDescription) -> dict[str, list[str]]:
    """Generates method definitions for getter and setter methods, excluding the declaration, including both braces. Returns in the form of a list.
    Index 0: `{`. Index 1: `\\treturn {attr_name};` or `\\t{attr_name} = new{attr_name};`. Index 2: `}`."""
    methods = {}
    # Create definition for getters and setters
    for attribute in classDesc.attributes:
        attribute: Attribute
        # Create getter method definition
        attr_name = get_attribute_name(attribute)
        if attribute.getter:
            methods[f"get_{attr_name}"] = ["{", f"\treturn {attr_name};", "}"]
        if attribute.setter:
            methods[f"set_{attr_name}"] = [
                "{", f"\t{attr_name} = new{attr_name};", "}"]
    return methods


def create_method_declarations(classDesc: ClassDescription) -> list[str]:
    """Generates getter and setter declarations for the class. If class is template
    class, the methods will be defined and declared here. Declarations are preceded by a `\\t`."""
    method_declarations = []
    method_definitions = {}
    # If class is template class, get definitions as they must be defined along with declarations
    if classDesc.template:
        method_definitions = get_method_definitions(classDesc)
        print(method_definitions)
    for attribute in classDesc.attributes:
        attribute: Attribute
        attr_name = get_attribute_name(attribute)
        # Create getter and setter declarations
        for method in ["get", "set"]:
            declaration = ""
            if method == "get" and attribute.getter:
                declaration += f"\t{attribute.type} get_{attr_name}() const"
            elif method == "set" and attribute.setter:
                declaration += f"\t void set_{attr_name}(const {attribute.type} &new{attr_name})"
            # If template, add method definition
            method_exists = (method == "get" and attribute.getter) or (
                method == "set" and attribute.setter)
            if classDesc.template and method_exists:
                definition = method_definitions.get(
                    f"{method}_{attr_name}", None)
                if definition == None:
                    raise ValueError(
                        f"Method definition for {method}_{attr_name} not found.")
                else:
                    declaration += "\n\t".join(definition)

            # Add declaration to list of method declarations
            if method_exists:
                declaration += ";"
                method_declarations.append(declaration)

    return method_declarations
